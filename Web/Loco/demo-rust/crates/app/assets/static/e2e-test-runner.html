<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>E2E Test Runner — demo-rust</title>
<!-- [REQ-N003] 브라우저 E2E 테스트 러너 (2026-02-07) -->
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body { font-family: 'Courier New', monospace; background: #1a1a2e; color: #e0e0e0; padding: 20px; }
  h1 { color: #00d4ff; margin-bottom: 4px; font-size: 1.4em; }
  .subtitle { color: #888; font-size: 0.85em; margin-bottom: 20px; }
  .controls { margin-bottom: 20px; display: flex; gap: 10px; align-items: center; }
  button { background: #00d4ff; color: #1a1a2e; border: none; padding: 8px 20px; font-family: inherit; font-weight: bold; cursor: pointer; border-radius: 4px; }
  button:hover { background: #00b8d9; }
  button:disabled { background: #555; color: #999; cursor: not-allowed; }
  .summary { display: flex; gap: 20px; margin-bottom: 16px; font-size: 0.9em; }
  .summary span { padding: 4px 12px; border-radius: 4px; }
  .s-total { background: #333; }
  .s-pass { background: #1b4332; color: #6bff6b; }
  .s-fail { background: #4a1025; color: #ff6b6b; }
  .s-skip { background: #3a3500; color: #ffd700; }
  .category { margin-bottom: 16px; }
  .category-title { color: #ffd700; font-size: 1.05em; margin-bottom: 6px; border-bottom: 1px solid #333; padding-bottom: 4px; }
  .test-row { display: flex; align-items: flex-start; padding: 4px 8px; border-radius: 3px; margin-bottom: 2px; font-size: 0.85em; }
  .test-row:hover { background: #222244; }
  .badge { display: inline-block; width: 52px; text-align: center; padding: 1px 0; border-radius: 3px; font-size: 0.8em; font-weight: bold; margin-right: 8px; flex-shrink: 0; }
  .badge-pass { background: #1b4332; color: #6bff6b; }
  .badge-fail { background: #4a1025; color: #ff6b6b; }
  .badge-skip { background: #3a3500; color: #ffd700; }
  .badge-run { background: #1a3a5c; color: #00d4ff; }
  .badge-wait { background: #333; color: #888; }
  .test-id { color: #aaa; width: 120px; flex-shrink: 0; }
  .test-name { flex: 1; }
  .test-detail { color: #888; font-size: 0.8em; margin-left: 188px; margin-bottom: 4px; }
  .test-detail.error { color: #ff6b6b; }
  #log { background: #111; border: 1px solid #333; border-radius: 4px; padding: 10px; margin-top: 16px; max-height: 300px; overflow-y: auto; font-size: 0.8em; line-height: 1.5; }
  .log-info { color: #00d4ff; }
  .log-ok { color: #6bff6b; }
  .log-err { color: #ff6b6b; }
  .log-warn { color: #ffd700; }
</style>
</head>
<body>
<h1>E2E Test Runner</h1>
<p class="subtitle">docs/test-scenarios.md 기반 18개 시나리오 자동 실행</p>

<div class="controls">
  <button id="btnRun" onclick="runAllTests()">Run All Tests</button>
  <span id="status" style="color:#888;">Ready</span>
</div>

<div class="summary">
  <span class="s-total">Total: <b id="cntTotal">18</b></span>
  <span class="s-pass">Pass: <b id="cntPass">0</b></span>
  <span class="s-fail">Fail: <b id="cntFail">0</b></span>
  <span class="s-skip">Skip: <b id="cntSkip">0</b></span>
</div>

<div id="results"></div>
<div id="log"></div>

<script>
// [REQ-N003] E2E 테스트 러너 JavaScript
const API = '';
let token = '';
let results = { pass: 0, fail: 0, skip: 0 };

// --- 유틸리티 ---
function log(msg, cls) {
  cls = cls || 'log-info';
  const el = document.getElementById('log');
  const div = document.createElement('div');
  div.className = cls;
  div.textContent = '[' + new Date().toLocaleTimeString() + '] ' + msg;
  el.appendChild(div);
  el.scrollTop = el.scrollHeight;
}

async function api(method, path, body, useAuth) {
  if (useAuth === undefined) useAuth = true;
  const headers = { 'Content-Type': 'application/json' };
  if (useAuth && token) headers['Authorization'] = 'Bearer ' + token;
  const opts = { method: method, headers: headers };
  if (body) opts.body = JSON.stringify(body);
  const res = await fetch(API + path, opts);
  let data = null;
  const text = await res.text();
  try { data = JSON.parse(text); } catch (e) { data = text; }
  return { status: res.status, ok: res.ok, data: data };
}

// --- UI 업데이트 ---
const scenarios = [
  { cat: 'TC-TRK: 트랙 관리', tests: [
    { id: 'TC-TRK-001', name: '트랙 등록' },
    { id: 'TC-TRK-002', name: '공개 트랙 목록 조회' },
    { id: 'TC-TRK-003', name: '공개/비공개 전환' },
    { id: 'TC-TRK-004', name: '트랙 수정' },
    { id: 'TC-TRK-005', name: '트랙 삭제' },
    { id: 'TC-TRK-006', name: '내 트랙 목록 조회' },
    { id: 'TC-TRK-007', name: '미인증 상태 트랙 등록 거부' },
    { id: 'TC-TRK-008', name: '음악 재생 플레이어 동작 확인' },
  ]},
  { cat: 'TC-VOTE: 투표', tests: [
    { id: 'TC-VOTE-001', name: 'Upvote 투표' },
    { id: 'TC-VOTE-002', name: 'Downvote 투표' },
    { id: 'TC-VOTE-003', name: '투표 변경 (upvote → downvote)' },
    { id: 'TC-VOTE-004', name: '투표 취소' },
    { id: 'TC-VOTE-005', name: '유효하지 않은 vote_type 거부' },
    { id: 'TC-VOTE-006', name: '미인증 상태 투표 거부' },
  ]},
  { cat: 'TC-CMT: 댓글 관리', tests: [
    { id: 'TC-CMT-001', name: '댓글 작성' },
    { id: 'TC-CMT-002', name: '댓글 목록 조회' },
    { id: 'TC-CMT-003', name: '댓글 삭제 (작성자)' },
    { id: 'TC-CMT-004', name: '미인증 상태 댓글 작성 거부' },
  ]},
];

function renderScenarios() {
  const container = document.getElementById('results');
  while (container.firstChild) container.removeChild(container.firstChild);
  scenarios.forEach(function(cat) {
    var catDiv = document.createElement('div');
    catDiv.className = 'category';
    var titleDiv = document.createElement('div');
    titleDiv.className = 'category-title';
    titleDiv.textContent = cat.cat;
    catDiv.appendChild(titleDiv);
    cat.tests.forEach(function(t) {
      var row = document.createElement('div');
      row.className = 'test-row';
      row.id = 'row-' + t.id;
      var badge = document.createElement('span');
      badge.className = 'badge badge-wait';
      badge.id = 'badge-' + t.id;
      badge.textContent = 'WAIT';
      var idSpan = document.createElement('span');
      idSpan.className = 'test-id';
      idSpan.textContent = t.id;
      var nameSpan = document.createElement('span');
      nameSpan.className = 'test-name';
      nameSpan.textContent = t.name;
      row.appendChild(badge);
      row.appendChild(idSpan);
      row.appendChild(nameSpan);
      catDiv.appendChild(row);
      var detail = document.createElement('div');
      detail.className = 'test-detail';
      detail.id = 'detail-' + t.id;
      detail.style.display = 'none';
      catDiv.appendChild(detail);
    });
    container.appendChild(catDiv);
  });
}

function setBadge(id, state, detail) {
  var badge = document.getElementById('badge-' + id);
  var detailEl = document.getElementById('detail-' + id);
  badge.className = 'badge badge-' + state;
  badge.textContent = state.toUpperCase();
  if (detail) {
    detailEl.style.display = 'block';
    detailEl.textContent = detail;
    detailEl.className = 'test-detail' + (state === 'fail' ? ' error' : '');
  }
}

function updateSummary() {
  document.getElementById('cntPass').textContent = results.pass;
  document.getElementById('cntFail').textContent = results.fail;
  document.getElementById('cntSkip').textContent = results.skip;
}

// --- 테스트 헬퍼 ---
function assert(cond, msg) {
  if (!cond) throw new Error(msg);
}

async function runTest(id, fn) {
  setBadge(id, 'run');
  try {
    await fn();
    setBadge(id, 'pass');
    results.pass++;
    log('PASS ' + id, 'log-ok');
  } catch (e) {
    setBadge(id, 'fail', e.message);
    results.fail++;
    log('FAIL ' + id + ': ' + e.message, 'log-err');
  }
  updateSummary();
}

// --- 메인 테스트 실행 ---
async function runAllTests() {
  document.getElementById('btnRun').disabled = true;
  document.getElementById('status').textContent = 'Running...';
  results = { pass: 0, fail: 0, skip: 0 };
  renderScenarios();
  updateSummary();

  // 로그인
  log('시드 데이터 사용자로 로그인 시도: user1@example.com');
  var loginRes = await api('POST', '/api/auth/login', { email: 'user1@example.com', password: 'password123' }, false);
  if (!loginRes.ok || !loginRes.data || !loginRes.data.token) {
    log('로그인 실패! 시드 데이터가 없을 수 있습니다. cargo loco task seed_data 실행 필요', 'log-err');
    document.getElementById('status').textContent = 'Login Failed';
    document.getElementById('btnRun').disabled = false;
    return;
  }
  token = loginRes.data.token;
  log('로그인 성공 (pid: ' + loginRes.data.pid + ')', 'log-ok');

  // 테스트에 사용할 변수
  var createdTrackId = null;
  var publicTrackId = null;
  var createdCommentId = null;

  // === TC-TRK ===

  // TC-TRK-001: 트랙 등록
  await runTest('TC-TRK-001', async function() {
    var res = await api('POST', '/api/tracks', {
      title: 'E2E Test Track',
      url: 'https://www.youtube.com/watch?v=e2e_test',
      artist: 'E2E Artist',
      description: 'Created by E2E test runner'
    });
    assert(res.status === 200, 'Expected 200, got ' + res.status + ': ' + JSON.stringify(res.data));
    assert(res.data.id, 'Missing track id');
    assert(res.data.is_public === false, 'Expected is_public=false, got ' + res.data.is_public);
    assert(res.data.vote_score === 0, 'Expected vote_score=0, got ' + res.data.vote_score);
    createdTrackId = res.data.id;
  });

  // TC-TRK-002: 공개 트랙 목록 조회
  await runTest('TC-TRK-002', async function() {
    var res = await api('GET', '/api/tracks', null, false);
    assert(res.status === 200, 'Expected 200, got ' + res.status);
    assert(Array.isArray(res.data.tracks), 'Expected tracks array');
    assert(res.data.tracks.length > 0, 'Expected at least 1 public track');
    for (var i = 1; i < res.data.tracks.length; i++) {
      assert(res.data.tracks[i-1].vote_score >= res.data.tracks[i].vote_score,
        'Tracks should be sorted by vote_score desc');
    }
    publicTrackId = res.data.tracks[0].id;
  });

  // TC-TRK-003: 공개/비공개 전환
  await runTest('TC-TRK-003', async function() {
    assert(createdTrackId, 'No track created (TC-TRK-001 prerequisite)');
    var res1 = await api('POST', '/api/tracks/' + createdTrackId + '/toggle-public');
    assert(res1.status === 200, 'Expected 200, got ' + res1.status);
    assert(res1.data.is_public === true, 'Expected is_public=true, got ' + res1.data.is_public);
    var res2 = await api('POST', '/api/tracks/' + createdTrackId + '/toggle-public');
    assert(res2.status === 200, 'Expected 200, got ' + res2.status);
    assert(res2.data.is_public === false, 'Expected is_public=false, got ' + res2.data.is_public);
  });

  // TC-TRK-004: 트랙 수정
  await runTest('TC-TRK-004', async function() {
    assert(createdTrackId, 'No track created (TC-TRK-001 prerequisite)');
    var res = await api('PUT', '/api/tracks/' + createdTrackId, {
      title: 'Updated E2E Track',
      artist: 'Updated Artist'
    });
    assert(res.status === 200, 'Expected 200, got ' + res.status);
    assert(res.data.title === 'Updated E2E Track', 'Expected updated title, got ' + res.data.title);
    assert(res.data.artist === 'Updated Artist', 'Expected updated artist, got ' + res.data.artist);
  });

  // TC-TRK-005: 트랙 삭제
  await runTest('TC-TRK-005', async function() {
    assert(createdTrackId, 'No track created (TC-TRK-001 prerequisite)');
    var res = await api('DELETE', '/api/tracks/' + createdTrackId);
    assert(res.status === 200, 'Expected 200, got ' + res.status);
  });

  // TC-TRK-006: 내 트랙 목록 조회
  await runTest('TC-TRK-006', async function() {
    var res = await api('GET', '/api/tracks/my');
    assert(res.status === 200, 'Expected 200, got ' + res.status);
    assert(Array.isArray(res.data.tracks), 'Expected tracks array');
  });

  // TC-TRK-007: 미인증 상태 트랙 등록 거부
  await runTest('TC-TRK-007', async function() {
    var res = await api('POST', '/api/tracks', {
      title: 'Unauthorized Track',
      url: 'https://www.youtube.com/watch?v=unauth'
    }, false);
    assert(res.status === 401, 'Expected 401, got ' + res.status);
  });

  // TC-TRK-008: 음악 재생 플레이어 동작 확인
  // [REQ-N004] 공개 트랙의 URL을 사용하여 embed URL 변환 및 플레이어 상태 검증
  await runTest('TC-TRK-008', async function() {
    // 1. 공개 트랙 목록에서 첫 번째 트랙 정보 가져오기
    var listRes = await api('GET', '/api/tracks', null, false);
    assert(listRes.status === 200, 'Failed to get public tracks');
    assert(listRes.data.tracks && listRes.data.tracks.length > 0, 'No public tracks available');
    var track = listRes.data.tracks[0];
    assert(track.title, 'Track missing title');
    assert(track.url, 'Track missing url');

    // 2. embed URL 변환 로직 검증 (player.js의 toEmbedUrl과 동일한 로직)
    var embedUrl = null;
    var ytMatch = track.url.match(/(?:youtube\.com\/watch\?v=|youtu\.be\/)([a-zA-Z0-9_-]{11})/);
    if (ytMatch) {
      embedUrl = 'https://www.youtube.com/embed/' + ytMatch[1] + '?autoplay=1&loop=1&playlist=' + ytMatch[1];
    } else if (track.url.includes('soundcloud.com')) {
      embedUrl = 'https://w.soundcloud.com/player/?url=' + encodeURIComponent(track.url) + '&auto_play=true';
    } else {
      embedUrl = track.url;
    }
    assert(embedUrl, 'Failed to generate embed URL');
    assert(embedUrl.includes('youtube.com/embed/') || embedUrl.includes('soundcloud.com/player/') || embedUrl === track.url,
      'Invalid embed URL format: ' + embedUrl);

    // 3. 플레이어 DOM 시뮬레이션 검증 (Player 객체 동작 검증)
    // 테스트 러너 페이지에는 Player가 없으므로, 인라인으로 핵심 로직을 검증
    var testPlayer = {
      playlist: [],
      currentIndex: -1,
      isPlaying: false,
      title: '',
      artist: '',
      iframeSrc: '',

      play: function(id, title, artist, url) {
        var existing = this.playlist.findIndex(function(t) { return t.id === id; });
        if (existing === -1) {
          this.playlist.push({ id: id, title: title, artist: artist, url: url });
          this.currentIndex = this.playlist.length - 1;
        } else {
          this.currentIndex = existing;
        }
        this.loadCurrent();
      },
      loadCurrent: function() {
        if (this.currentIndex < 0 || this.currentIndex >= this.playlist.length) return;
        var t = this.playlist[this.currentIndex];
        this.title = t.title;
        this.artist = t.artist || '';
        this.iframeSrc = embedUrl;
        this.isPlaying = true;
      }
    };

    testPlayer.play(track.id, track.title, track.artist || '', track.url);

    // 4. 플레이어 상태 검증
    assert(testPlayer.isPlaying === true, 'Expected isPlaying=true, got ' + testPlayer.isPlaying);
    assert(testPlayer.title === track.title, 'Expected title="' + track.title + '", got "' + testPlayer.title + '"');
    assert(testPlayer.iframeSrc === embedUrl, 'Expected iframe src="' + embedUrl + '", got "' + testPlayer.iframeSrc + '"');
    assert(testPlayer.playlist.length === 1, 'Expected playlist length=1, got ' + testPlayer.playlist.length);
    assert(testPlayer.currentIndex === 0, 'Expected currentIndex=0, got ' + testPlayer.currentIndex);
  });

  // === TC-VOTE ===
  if (!publicTrackId) {
    log('공개 트랙이 없어 투표 테스트를 건너뜁니다', 'log-warn');
    ['TC-VOTE-001','TC-VOTE-002','TC-VOTE-003','TC-VOTE-004','TC-VOTE-005','TC-VOTE-006'].forEach(function(id) {
      setBadge(id, 'skip', 'No public track available');
      results.skip++;
    });
    updateSummary();
  } else {
    // 기존 투표 삭제 (깨끗한 상태)
    await api('DELETE', '/api/tracks/' + publicTrackId + '/vote');

    var trackBefore = await api('GET', '/api/tracks/' + publicTrackId, null, false);
    var scoreBefore = trackBefore.data.vote_score;

    // TC-VOTE-001: Upvote 투표
    await runTest('TC-VOTE-001', async function() {
      var res = await api('POST', '/api/tracks/' + publicTrackId + '/vote', { vote_type: 1 });
      assert(res.status === 200, 'Expected 200, got ' + res.status);
      assert(res.data.vote_type === 1, 'Expected vote_type=1, got ' + res.data.vote_type);
      var track = await api('GET', '/api/tracks/' + publicTrackId, null, false);
      assert(track.data.vote_score === scoreBefore + 1, 'Expected vote_score=' + (scoreBefore + 1) + ', got ' + track.data.vote_score);
    });

    // TC-VOTE-002: Downvote 투표
    await runTest('TC-VOTE-002', async function() {
      var listRes = await api('GET', '/api/tracks', null, false);
      var otherTrack = listRes.data.tracks.find(function(t) { return t.id !== publicTrackId; });
      assert(otherTrack, 'No other public track available for downvote test');
      await api('DELETE', '/api/tracks/' + otherTrack.id + '/vote');
      var before = await api('GET', '/api/tracks/' + otherTrack.id, null, false);
      var sB = before.data.vote_score;
      var res = await api('POST', '/api/tracks/' + otherTrack.id + '/vote', { vote_type: -1 });
      assert(res.status === 200, 'Expected 200, got ' + res.status);
      assert(res.data.vote_type === -1, 'Expected vote_type=-1, got ' + res.data.vote_type);
      var after = await api('GET', '/api/tracks/' + otherTrack.id, null, false);
      assert(after.data.vote_score === sB - 1, 'Expected vote_score=' + (sB - 1) + ', got ' + after.data.vote_score);
      await api('DELETE', '/api/tracks/' + otherTrack.id + '/vote');
    });

    // TC-VOTE-003: 투표 변경 (upvote → downvote)
    await runTest('TC-VOTE-003', async function() {
      var before = await api('GET', '/api/tracks/' + publicTrackId, null, false);
      var sB = before.data.vote_score;
      var res = await api('POST', '/api/tracks/' + publicTrackId + '/vote', { vote_type: -1 });
      assert(res.status === 200, 'Expected 200, got ' + res.status);
      assert(res.data.vote_type === -1, 'Expected vote_type=-1, got ' + res.data.vote_type);
      var after = await api('GET', '/api/tracks/' + publicTrackId, null, false);
      assert(after.data.vote_score === sB - 2, 'Expected vote_score=' + (sB - 2) + ', got ' + after.data.vote_score);
    });

    // TC-VOTE-004: 투표 취소
    await runTest('TC-VOTE-004', async function() {
      var before = await api('GET', '/api/tracks/' + publicTrackId, null, false);
      var sB = before.data.vote_score;
      var res = await api('DELETE', '/api/tracks/' + publicTrackId + '/vote');
      assert(res.status === 200, 'Expected 200, got ' + res.status);
      var after = await api('GET', '/api/tracks/' + publicTrackId, null, false);
      assert(after.data.vote_score === sB + 1, 'Expected vote_score=' + (sB + 1) + ', got ' + after.data.vote_score);
    });

    // TC-VOTE-005: 유효하지 않은 vote_type 거부
    await runTest('TC-VOTE-005', async function() {
      var res = await api('POST', '/api/tracks/' + publicTrackId + '/vote', { vote_type: 2 });
      assert(res.status === 400, 'Expected 400, got ' + res.status);
    });

    // TC-VOTE-006: 미인증 상태 투표 거부
    await runTest('TC-VOTE-006', async function() {
      var res = await api('POST', '/api/tracks/' + publicTrackId + '/vote', { vote_type: 1 }, false);
      assert(res.status === 401, 'Expected 401, got ' + res.status);
    });
  }

  // === TC-CMT ===
  if (!publicTrackId) {
    log('공개 트랙이 없어 댓글 테스트를 건너뜁니다', 'log-warn');
    ['TC-CMT-001','TC-CMT-002','TC-CMT-003','TC-CMT-004'].forEach(function(id) {
      setBadge(id, 'skip', 'No public track available');
      results.skip++;
    });
    updateSummary();
  } else {
    // TC-CMT-001: 댓글 작성
    await runTest('TC-CMT-001', async function() {
      var res = await api('POST', '/api/tracks/' + publicTrackId + '/comments', { content: 'E2E test comment!' });
      assert(res.status === 200, 'Expected 200, got ' + res.status);
      assert(res.data.id, 'Missing comment id');
      assert(res.data.content === 'E2E test comment!', 'Expected matching content, got ' + res.data.content);
      createdCommentId = res.data.id;
    });

    // TC-CMT-002: 댓글 목록 조회
    await runTest('TC-CMT-002', async function() {
      var res = await api('GET', '/api/tracks/' + publicTrackId + '/comments', null, false);
      assert(res.status === 200, 'Expected 200, got ' + res.status);
      assert(Array.isArray(res.data.comments), 'Expected comments array');
      assert(res.data.comments.length > 0, 'Expected at least 1 comment');
    });

    // TC-CMT-003: 댓글 삭제 (작성자)
    await runTest('TC-CMT-003', async function() {
      assert(createdCommentId, 'No comment created (TC-CMT-001 prerequisite)');
      var res = await api('DELETE', '/api/tracks/' + publicTrackId + '/comments/' + createdCommentId);
      assert(res.status === 200, 'Expected 200, got ' + res.status);
    });

    // TC-CMT-004: 미인증 상태 댓글 작성 거부
    await runTest('TC-CMT-004', async function() {
      var res = await api('POST', '/api/tracks/' + publicTrackId + '/comments', { content: 'Unauthorized comment' }, false);
      assert(res.status === 401, 'Expected 401, got ' + res.status);
    });
  }

  // 완료
  var total = results.pass + results.fail + results.skip;
  var statusEl = document.getElementById('status');
  if (results.fail === 0) {
    statusEl.textContent = 'All ' + results.pass + '/' + total + ' tests passed!';
    statusEl.style.color = '#6bff6b';
  } else {
    statusEl.textContent = 'Done: ' + results.fail + ' failed';
    statusEl.style.color = '#ff6b6b';
  }
  log('테스트 완료: ' + results.pass + ' pass, ' + results.fail + ' fail, ' + results.skip + ' skip',
    results.fail === 0 ? 'log-ok' : 'log-err');
  document.getElementById('btnRun').disabled = false;
}

// 초기 렌더링
renderScenarios();
</script>
</body>
</html>
